Оптимизация циклов.

Источники оптимизации:


-- Индуктивные переменные
И.П. -- переменная, которая многократно (например, в цикле) увеличивается или уменьшается на определённое число. То есть переменная по сути является линейной функцией от значения переменной-счётчика.
Пример:
for {int i = 0; i < 10; ++i) {
	int j = 17 * i;
}

Снижение стоимости операций -- вид оптимизации, при котором более дорогие операции заменяются эквивалентными, более дешёвыми по времени операциями.
Пример: замена умножений в цикле на сложения.

Мёртвый код -- часть кода, результат исполнения которого больше нигде в программе не используется. Выполнение такого кода -- бессмысленная трата вычислительного времени и памяти.



-- Расщепление циклов
Цикл разбивается в несколько меньших циклов, каждый из которых заключает часть тела исходного цикла. Это позволяет организовать такую последовательность команд, которая будет обладать лучшей локальностью в смысле доступа к данным.
Пример:
int a[1000];
int b[1000];
int c[1000];
for (int i = 0; i < 1000; ++i) {
	printf("%d", a[i]);
	printf("%d", b[i]);
	printf("%d", c[i]);
}

Заменяется на:
int a[1000];
int b[1000];
int c[1000];
for (int i = 0; i < 1000; ++i) {
	printf("%d", a[i]);
}
for (int i = 0; i < 1000; ++i) {
	printf("%d", b[i]);
}
for (int i = 0; i < 1000; ++i) {
	printf("%d", c[i]);
}


-- Слияние циклов
Иногда ради снижения накладных расходов на организацию цикла имеет смысл слить два соседних цикла, которые будут выполняться одинаковое количество раз, в один, если только они не обрабатывают одни и те же данные.


-- Инверсия цикла
Данная оптимизация изменяет цикл while на цикл do/while, завёрнутый в условие if. Таким образом, число прыжков в коде сокращается на два, для случаев, когда цикл выполняется хотя бы раз. Эффективность заключается в том, что прыжки обычно вызывают сброс процессорного ковейера. Кроме того, если начальное условие известно во время компиляции, и цикл не содержит побочных эффектов, то условный оператор в начале может быть опущен.


-- Перестановка циклов
Для вложенных циклов иногда можно поменять местами внутренний и внешний циклы. Эту технику можно использовать для достижения локальности ссылок при работе с многомерными массивами: порядок обращения к элементам такого массива должен соответствовать представлению элементов в памяти.
Пример:
for (int i = 0; i < 10; ++i)
	for (int j = 0; j < 20; ++j)
		a[i, j] = i + j;

Заменяется на
for (int j = 0; j < 20; ++j)
	for (int i = 0; i < 10; ++i)
		a[i, j] = i + j;


-- Вынос инвариант из цикла
Инварианта цикла -- значение, которое не изменяется на протяжении работы цикла.
Если цикл содержит инварианту, которая перевычисляется на каждой итерации, то можно вынести её вычисление за цикл.
Пример:
for (int i = 0; i < 100; ++i)
	float a = i + pi / 2;

Заменяется на:
const float HALF_PI = pi / 2;
for (int i = 0; i < 100; ++i)
	float a = i + HALF_PI;


-- Раскручивание цикла
Данная техника дополняет тело цикла, копируя его для соседних значений счётчика. Таким образом, уменьшается количество итераций и, как следствие, количество проверок условия цикла, которые значительно снижают производительность.
Пример:
for (int i = 0; i < 5000; ++i)
	a[i] = i;

Заменяется на
for (int i = 0; i < 1000; i+=5) {
	a[i] = i;
	a[i + 1] = i + 1;
	a[i + 2] = i + 2;
	a[i + 3] = i + 3;
	a[i + 4] = i + 4;
}


-- Разделение цикла
Цикл можно оптимизировать, разделив его в несколько упрощенных циклов

Эта техника пытается упростить цикл или исключить зависимости посредством разбиения его в несколько циклов, которые имеют одинаковые тела, но итерируются по разным диапазонам счётчика.

Частный случай этой техники -- отслаивание цикла.
Если несколько первых итераций качественно отличаются от всех последующих, то их можно организовать в отдельный цикл.
Пример:
int p = 10;
for (int i = 0; i < 10; ++i) {
	y[i] = x[i] + x[p];
	p = i;
}

Заменяется на:
y[0] = x[0] + x[10];
for (int i = 1; i < 10; ++i) {
	y[i] = x[i] + x[i - 1];
}


-- Размыкание цикла
Размыкание выносит из цикла условие, находящееся внутри него, посредством копирования тела цикла, и помещения его внутрь каждого оператора if и else.

Пример:
int i, w, x[1000], y[1000];
for (i = 0; i < 1000; ++i) {
x[i] += y[i];
if (w)
  y[i] = 0;
}

Заменяется на:
int i, w, x[1000], y[1000];
if (w) {
	for (i = 0; i < 1000; i++) {
	  x[i] += y[i];
	  y[i] = 0;
}
} else {
	for (i = 0; i < 1000; i++) {
	  x[i] += y[i];
}
}


-- Программный конвейер
Тело цикла реструктурируется таким образом, чтобы работа, совершаемая в пределах одной итерации разделилась на несколько частей и выполнилась в течение нескольких итераций. Такой подход позволяет снизить или исключить задержку между загрузкой данных и их использованием.


-- Распараллеливание
Код цикл преобразуется в многопоточный или векторизованный, чтобы использовать несколько вычислителей одновременно.

Описанную выше технику "раскручивания" цикла можно усовершенствовать, заменив многократное выполнение скалярной инструкции на одно выполнение скалярной инструкции.

Для того, чтобы разбить цикл в несколько потоков, нужно учитывать зависимость по данным. Чем она меньше, тем проще распараллелить цикл.

Источник: https://en.wikipedia.org/wiki/Optimizing_compiler#Loop_optimizations
